{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pie On A Plate Productions Coding Standards About This documentation covers the basics of the Coding Standards followed by Pie On A Plate Productions. Here are the highlights: Example Code File Structure Naming Conventions Optimization Techniques and Best Practices Credits These coding standards have been created and are maintained by David Campbell III.","title":"About"},{"location":"#pie-on-a-plate-productions-coding-standards","text":"","title":"Pie On A Plate Productions Coding Standards"},{"location":"#about","text":"This documentation covers the basics of the Coding Standards followed by Pie On A Plate Productions. Here are the highlights: Example Code File Structure Naming Conventions Optimization Techniques and Best Practices","title":"About"},{"location":"#credits","text":"These coding standards have been created and are maintained by David Campbell III.","title":"Credits"},{"location":"code-file-structure/","text":"Code File Structure Each script file should be laid out in the same general manner. //namespaces using UnityEngine; using System; //aliases using Random = UnityEngine.Random; public class MyClass { //consts, most accessible to least accessible public const int INT_CONST = 10; private const string FAVE_WORD = \"Pie\"; //statics, public only public static float someStaticNum = 69.420f; //region named \"Nested Structures\" containing all nested classes, structs, enums etc. #region Nested Structures private class SomeNestedClass { public SomeNestedClass() { Debug.Log(\"Created nested class!\"); } } private enum SomeNestedEnum { ENUM_ELEMENT_1, ENUM_ELEMENT_2 } #endregion //exposed fields and their properties, if any [SerializeField, Tooltip(\"This is an int, it is used for nothing\")] private int _someInt; public int someInt { get => _someInt; private set => _someInt = value; } [SerializeField, Range(0f, 10f), Tooltip(\"A ranged float with no associated property\")] private float floatWithoutProperty; [SerializeField] private string _firstName = \"DefaultFirstName\"; public string firstName => _firstName; [SerializeField] private string _lastName = \"DefaultLastName\"; public string lastName => _lastName; //properties that perform meaningful calculations or operations // beyond simple assignments public string FullName => $\"{firstName} {lastName}\"; //auto properties public Transform thisTransform { get; private set; } //private fields private int privateInt = 1; private bool privateBool; //private static fields private static bool privateStaticBool = false; //methods relating to init, Start, Awake, OnEnable etc. private void Start() { //caching thisTransform = this.transform; } //methods relating to Update, FixedUpdate, LateUpdate etc. private void Update() { privateInt++; } //any other methods public void SomeMethod() { } private void AnotherMethod() { } //debugging methods #region Debugging //preprocessor statements should always be left aligned //so that stand out from #regions #if UNITY_EDITOR private void OnDrawGizmos() { } private void SomeOtherDebugMethod() { } #endif #endregion }","title":"Code File Structure"},{"location":"code-file-structure/#code-file-structure","text":"Each script file should be laid out in the same general manner. //namespaces using UnityEngine; using System; //aliases using Random = UnityEngine.Random; public class MyClass { //consts, most accessible to least accessible public const int INT_CONST = 10; private const string FAVE_WORD = \"Pie\"; //statics, public only public static float someStaticNum = 69.420f; //region named \"Nested Structures\" containing all nested classes, structs, enums etc. #region Nested Structures private class SomeNestedClass { public SomeNestedClass() { Debug.Log(\"Created nested class!\"); } } private enum SomeNestedEnum { ENUM_ELEMENT_1, ENUM_ELEMENT_2 } #endregion //exposed fields and their properties, if any [SerializeField, Tooltip(\"This is an int, it is used for nothing\")] private int _someInt; public int someInt { get => _someInt; private set => _someInt = value; } [SerializeField, Range(0f, 10f), Tooltip(\"A ranged float with no associated property\")] private float floatWithoutProperty; [SerializeField] private string _firstName = \"DefaultFirstName\"; public string firstName => _firstName; [SerializeField] private string _lastName = \"DefaultLastName\"; public string lastName => _lastName; //properties that perform meaningful calculations or operations // beyond simple assignments public string FullName => $\"{firstName} {lastName}\"; //auto properties public Transform thisTransform { get; private set; } //private fields private int privateInt = 1; private bool privateBool; //private static fields private static bool privateStaticBool = false; //methods relating to init, Start, Awake, OnEnable etc. private void Start() { //caching thisTransform = this.transform; } //methods relating to Update, FixedUpdate, LateUpdate etc. private void Update() { privateInt++; } //any other methods public void SomeMethod() { } private void AnotherMethod() { } //debugging methods #region Debugging //preprocessor statements should always be left aligned //so that stand out from #regions #if UNITY_EDITOR private void OnDrawGizmos() { } private void SomeOtherDebugMethod() { } #endif #endregion }","title":"Code File Structure"},{"location":"fields-variables/","text":"Fields/Variables Accessor Types All fields should remain as private as possible. If inheritance is involved, fields should gravitate towards having protected access as opposed to public access. default accessor type (ie no specified type) should never be used. When no type is specified, the accessor type assumes internal (which is slightly different from public ) for classes, and private for class members, Might as well specify private to be more readable and explicit. If a field must be exposed in the Inspector for easy editing access, it should be serialized. [SerializeField] private int myIntField = 10; This will keep the variable private to the rest of the codebase, but expose it to the Inspector. If a field should be read-only, it should be made into a property. If a field should be read-only, with the exception of the Inspector, it should be made into a property. To see how to achieve either of these, see properties Data Types All fields (and any other variable for that matter) should be explicit when declaring a data type. No local variable should use var for its data type. double s are not used in much of Unity\u2019s API, so float s should be used in all cases instead. Naming Fields/variables should be named in camelCase. Tooltips In order to create the easiest to use API from the code to the front end development and designing of the game, add tooltip attributes to make viewing the purpose of the field from the Inspector as easy and seamless as possible. All exposed fields should have a tooltip, unless they are extremely self-explanatory. When in doubt, it never hurts to be specific about the purpose of the field! For the best readability, tooltip attributes should always be placed last in the attribute list, and on their own separate line. They should be indented as to provide a visual break between the other attributes. [SerializeField, Tooltip(\"Current health of the player\")] private float currentHealth = 100f; Warning Suppression Warnings can certainly be useful, but sometimes they are annoying, as they don\u2019t always interface well with Unity\u2019s workflow. Specific, warning 0649 about how a variable is declared but never initialized can be frustrating, as a lot of variables are declared in code, and then assigned a value through Unity\u2019s Inspector. Suppressing these warnings is easy to do, and keeps the console clean. Simply add #pragma warning disable <WARNING_CODE> to the start of where the warning should be suppressed. Be sure to restore the error after all variables intended to suppress to avoid suppressing the warning throughout the entire file. This can be done by simply writing #pragma warning restore <WARNING_CODE> . #pragma warning disable 0649 [SerializeField] private int num; //to be assigned in Inspector [SerializeField] private GameObject someObject; //to be assigned in Inspector #pragma warning restore 0649 //be sure to restore the error after all intending variables so it is not accidentally // suppressed throughout the entirety of the file","title":"Fields/Variables"},{"location":"fields-variables/#fieldsvariables","text":"","title":"Fields/Variables"},{"location":"fields-variables/#accessor-types","text":"All fields should remain as private as possible. If inheritance is involved, fields should gravitate towards having protected access as opposed to public access. default accessor type (ie no specified type) should never be used. When no type is specified, the accessor type assumes internal (which is slightly different from public ) for classes, and private for class members, Might as well specify private to be more readable and explicit. If a field must be exposed in the Inspector for easy editing access, it should be serialized. [SerializeField] private int myIntField = 10; This will keep the variable private to the rest of the codebase, but expose it to the Inspector. If a field should be read-only, it should be made into a property. If a field should be read-only, with the exception of the Inspector, it should be made into a property. To see how to achieve either of these, see properties","title":"Accessor Types"},{"location":"fields-variables/#data-types","text":"All fields (and any other variable for that matter) should be explicit when declaring a data type. No local variable should use var for its data type. double s are not used in much of Unity\u2019s API, so float s should be used in all cases instead.","title":"Data Types"},{"location":"fields-variables/#naming","text":"Fields/variables should be named in camelCase.","title":"Naming"},{"location":"fields-variables/#tooltips","text":"In order to create the easiest to use API from the code to the front end development and designing of the game, add tooltip attributes to make viewing the purpose of the field from the Inspector as easy and seamless as possible. All exposed fields should have a tooltip, unless they are extremely self-explanatory. When in doubt, it never hurts to be specific about the purpose of the field! For the best readability, tooltip attributes should always be placed last in the attribute list, and on their own separate line. They should be indented as to provide a visual break between the other attributes. [SerializeField, Tooltip(\"Current health of the player\")] private float currentHealth = 100f;","title":"Tooltips"},{"location":"fields-variables/#warning-suppression","text":"Warnings can certainly be useful, but sometimes they are annoying, as they don\u2019t always interface well with Unity\u2019s workflow. Specific, warning 0649 about how a variable is declared but never initialized can be frustrating, as a lot of variables are declared in code, and then assigned a value through Unity\u2019s Inspector. Suppressing these warnings is easy to do, and keeps the console clean. Simply add #pragma warning disable <WARNING_CODE> to the start of where the warning should be suppressed. Be sure to restore the error after all variables intended to suppress to avoid suppressing the warning throughout the entire file. This can be done by simply writing #pragma warning restore <WARNING_CODE> . #pragma warning disable 0649 [SerializeField] private int num; //to be assigned in Inspector [SerializeField] private GameObject someObject; //to be assigned in Inspector #pragma warning restore 0649 //be sure to restore the error after all intending variables so it is not accidentally // suppressed throughout the entirety of the file","title":"Warning Suppression"},{"location":"methods/","text":"Methods Accessor Types All methods should remain as private as possible. default accessor type (ie no specified type) should never be used, even with default Unity methods. When no type is specified, the accessor type assumes internal , which is slightly different from private . Might as well specify private to be more readable anyhow. private void Start() { //empty } private void MyCustomMethod(Collider col) { //empty } Naming Methods should be named in PascalCase.","title":"Methods"},{"location":"methods/#methods","text":"","title":"Methods"},{"location":"methods/#accessor-types","text":"All methods should remain as private as possible. default accessor type (ie no specified type) should never be used, even with default Unity methods. When no type is specified, the accessor type assumes internal , which is slightly different from private . Might as well specify private to be more readable anyhow. private void Start() { //empty } private void MyCustomMethod(Collider col) { //empty }","title":"Accessor Types"},{"location":"methods/#naming","text":"Methods should be named in PascalCase.","title":"Naming"},{"location":"namespaces/","text":"Namespaces Currently, no native part of the codebase uses any specific namespace. This may change as the program progresses in size, and is subject to further discussion. For now, let\u2019s keep it simple and avoid namespaces.","title":"Namespaces"},{"location":"namespaces/#namespaces","text":"Currently, no native part of the codebase uses any specific namespace. This may change as the program progresses in size, and is subject to further discussion. For now, let\u2019s keep it simple and avoid namespaces.","title":"Namespaces"},{"location":"naming/","text":"Naming Conventions All elements should be named according to the following naming conventions: Type Naming Convention Fields/Variables camelCase Const Fields/Variables ALL_UPPER_CASE_SNAKE_CASE Properties camelCase if simple getter or setter PascalCase if performing calculation or operation more advanced than a simple check or assignment. See property naming for examples. Classes PascalCase Enums PascalCase Enum elements ALL_UPPER_CASE_SNAKE_CASE Interfaces PascalCase Methods PascalCase Structs PascalCase Namespaces PascalCase","title":"Naming Conventions"},{"location":"naming/#naming-conventions","text":"All elements should be named according to the following naming conventions: Type Naming Convention Fields/Variables camelCase Const Fields/Variables ALL_UPPER_CASE_SNAKE_CASE Properties camelCase if simple getter or setter PascalCase if performing calculation or operation more advanced than a simple check or assignment. See property naming for examples. Classes PascalCase Enums PascalCase Enum elements ALL_UPPER_CASE_SNAKE_CASE Interfaces PascalCase Methods PascalCase Structs PascalCase Namespaces PascalCase","title":"Naming Conventions"},{"location":"optimization-techniques/","text":"Optimization Techniques Caching Components Caching components is one of the best things you can do in Unity to improve/maintain the performance of a game. Caching a component is as simple as saving off a reference of that component during the Start() or Awake() method. Note that the .transform property of gameObjects should be cached as well, as it is a near equivalent of GetComponent<>() , which is slow. private Collider myCollider; private void Start() { myCollider = GetComponent<Collider>(); } Caching Objects Just like components, objects can also be cached during Start() or Awake() to save on the overhead of instance creation. A good example of this is WaitForSeconds used repeatedly in a coroutine. [SerializeField] private float waitTime = 5f; private WaitForSeconds waitForWaitTime; private void Start() { waitForWaitTime = new WaitForSeconds(waitTime); } Avoid \u201cFind\u201d methods Unless there is a very good reason to do so, avoid using any form of \u201cFind\u201d method at all costs. These are incredibly slow, and should only ever be used in a Start() or Awake() method (or some other method that only gets called once). Examples of \u201cFind\u201d methods include GameObject.Find() , GameObject.FindObjectsWithTag() , GameObject.FindObjectWithTag() etc. Avoid .transform Instead of using .transform to get an object\u2019s transform constantly, use it once to cache. Typically, a variable called thisTransform can be used to achieve this. private Transform thisTransform; private void Start() { //or just \u2018transform\u2019 instead of \u2018this.transform\u2019, works the same way thisTransform = this.transform; } CompareTag() instead of .tag When a tag check is needed, use CompareTag() instead of checking tag equality with an object\u2019s .tag property. It is far faster, especially when used frequently. As we will see below in the Layer Masking section of this document, it is even faster to avoid tag checks altogether where possible. private void OnTriggerEnter(Collider other) { if(other.CompareTag(\"Player\")) { //do something } } Material Instancing All materials should be instanced whenever possible in order to speed up the rendering process. This can be done by checking the \u201cEnable GPU Instancing\u201d box near the bottom of all materials using the Standard shader (as well as a lot of other custom shaders). Material Editing When editing a material, it is best to edit a material overall instead of that specific instance of the material. Let\u2019s say we want to make a color change on a material. One might be tempted to access the material like so: Renderer rend; Material matToEdit = rend.material; Avoid doing this whenever possible. This will create a duplicate instance copy of the material. Poor material management is one of the top bottlenecks for performance in game (as it is a great factor in the number of batches that are made when the game renders each frame). If a material needs to be adjusted, consider using the sharedMaterial property instead. Renderer rend; Material matToEdit = rend.sharedMaterial; This will grab the material from the renderer without creating a duplicate instance of it. This, however, has the downside of affecting all other objects that use this material. If we want to change a property of a material on one specific object that uses a material that many other objects share, without modifying the look of the other objects sharing the material, it is recommended to simply create a new material and assign it to the object that must change. This is especially true if the object\u2019s material will be changing frequently, like a glow pulsing, light flickering etc. If an object with a frequently changing material has its own material, then sharedMaterial can be used to avoid the instantiation of a new material whenever it changes. Coroutines Coroutines are not only a way to script a series of events over a period of time, but can also be a powerful alternative to methods that execute far more frequently than is needed, and with far more overhead, such as Update() . Continuous Updates When a function needs to update on a frame-by-frame basis, but only for a set period of time (as opposed to constantly), one can use WaitForEndOfFrame within a coroutine, and only start the coroutine when needed. private IEnumerator WaitForSomething() { while(enabled) { yield return new WaitForEndOfFrame(); //better to cache this object in Start() //do something } } IMPORTANT : WaitForEndOfFrame should only be used for graphical specific functions that require operations to be performed at the very end of a frame. If your function does not require this (most don't), yield return null is the appropriate alternative. Delayed Updates When a function needs to update frequently, but not necessarily exactly every frame, waiting for a short time period within a loop inside a coroutine is a more efficient alternative to the Update() method. private IEnumerator WaitForSomethingElse() { while(enabled) { //0.05 equates to 20 times a second, a fairly efficient alternative to most things that // need to be constantly updated yield return new WaitForSeconds(0.05f); //do something } } WaitForFixedUpdate can also be used for physics based operations, an efficient alternative to FixedUpdate() . Please note that each of the above coroutine examples incorporate the use of a loop instead of recursion. This is because C# does not support proper tail culling in recursive statements. This means that a long running recursive function will continue to allocate stack frames, which could have the potential for issues if it runs long enough. Using a loop that is based on if the object is enabled or not is a good fix that achieves effectively the same thing as the infinitely recursive approach. When to Use Coroutines over Update() or FixedUpdate() If deciding between using a coroutine that waits for the end of the frame (or waits null ) and the standard Update() method, the best option depends on the amount of control you desire over your updating. For example, if you require the ability to stop one part of a script from updating, but not other parts, then coroutines are your best bet, as there can be multiple coroutines associated with a single MonoBehavior that can be started and stopped independently from one another. However, if your script simply requires a single constant update loop, then Update() is preferred due to less overhead per method call. In fact, Update() should always be preferred over an infinite, slightly delayed coroutine due to the overhead associated with coroutine execution. Waiting about 20 times a second using a coroutine as opposed to 60 times a second using Update() may not increase performance if the overhead of the coroutine calls exceed whatever performance is gained by running the code in the update fewer times. In summary, only use coroutines for performance purposes if the code being executed each time is very expensive. Layer Masking When making use of trigger-related methods such as OnTriggerEnter() or OnTriggerStay() etc., consider if an opportunity to utilize layer masking becomes available. Layer masking allows for physics-based operations to ignore certain predefined layers, which can help to speed up any mechanic that is reliant on these physics-based operations, especially if they are utilized frequently or in great quantities. By only including some layers into physics calculations (such as triggers or raycasts), tag checks (or checking if needed components are on the colliding object) are avoided, speeding things up considerably. Let\u2019s say we have 2 layers: Player and PlayerOnly . PlayerOnly , as the name suggests, only collides with objects on the Player layer. When the script below is attached to an object with a trigger and the layer of PlayerOnly , no tag check is needed, because we know with certainty that it will only ever collide with the Player . private void OnTriggerEnter(Collider other) { //because this script was placed on an object with layer PlayerOnly, //no tag check is needed, and we don't need to worry about PlayerHealth not existing //on the colliding object other.GetComponent<PlayerHealth>().DoSomething(); } The downside to using layer masking instead of tag/component checking is that it is typically harder to debug, especially when many different interacting layers are involved. It is essential to carefully track each layer and plan how it may/may not interact with another to maximize the usefulness of this technique.","title":"Optimization Techniques"},{"location":"optimization-techniques/#optimization-techniques","text":"","title":"Optimization Techniques"},{"location":"optimization-techniques/#caching-components","text":"Caching components is one of the best things you can do in Unity to improve/maintain the performance of a game. Caching a component is as simple as saving off a reference of that component during the Start() or Awake() method. Note that the .transform property of gameObjects should be cached as well, as it is a near equivalent of GetComponent<>() , which is slow. private Collider myCollider; private void Start() { myCollider = GetComponent<Collider>(); }","title":"Caching Components"},{"location":"optimization-techniques/#caching-objects","text":"Just like components, objects can also be cached during Start() or Awake() to save on the overhead of instance creation. A good example of this is WaitForSeconds used repeatedly in a coroutine. [SerializeField] private float waitTime = 5f; private WaitForSeconds waitForWaitTime; private void Start() { waitForWaitTime = new WaitForSeconds(waitTime); }","title":"Caching Objects"},{"location":"optimization-techniques/#avoid-find-methods","text":"Unless there is a very good reason to do so, avoid using any form of \u201cFind\u201d method at all costs. These are incredibly slow, and should only ever be used in a Start() or Awake() method (or some other method that only gets called once). Examples of \u201cFind\u201d methods include GameObject.Find() , GameObject.FindObjectsWithTag() , GameObject.FindObjectWithTag() etc.","title":"Avoid \u201cFind\u201d methods"},{"location":"optimization-techniques/#avoid-transform","text":"Instead of using .transform to get an object\u2019s transform constantly, use it once to cache. Typically, a variable called thisTransform can be used to achieve this. private Transform thisTransform; private void Start() { //or just \u2018transform\u2019 instead of \u2018this.transform\u2019, works the same way thisTransform = this.transform; }","title":"Avoid .transform"},{"location":"optimization-techniques/#comparetag-instead-of-tag","text":"When a tag check is needed, use CompareTag() instead of checking tag equality with an object\u2019s .tag property. It is far faster, especially when used frequently. As we will see below in the Layer Masking section of this document, it is even faster to avoid tag checks altogether where possible. private void OnTriggerEnter(Collider other) { if(other.CompareTag(\"Player\")) { //do something } }","title":"CompareTag() instead of .tag"},{"location":"optimization-techniques/#material-instancing","text":"All materials should be instanced whenever possible in order to speed up the rendering process. This can be done by checking the \u201cEnable GPU Instancing\u201d box near the bottom of all materials using the Standard shader (as well as a lot of other custom shaders).","title":"Material Instancing"},{"location":"optimization-techniques/#material-editing","text":"When editing a material, it is best to edit a material overall instead of that specific instance of the material. Let\u2019s say we want to make a color change on a material. One might be tempted to access the material like so: Renderer rend; Material matToEdit = rend.material; Avoid doing this whenever possible. This will create a duplicate instance copy of the material. Poor material management is one of the top bottlenecks for performance in game (as it is a great factor in the number of batches that are made when the game renders each frame). If a material needs to be adjusted, consider using the sharedMaterial property instead. Renderer rend; Material matToEdit = rend.sharedMaterial; This will grab the material from the renderer without creating a duplicate instance of it. This, however, has the downside of affecting all other objects that use this material. If we want to change a property of a material on one specific object that uses a material that many other objects share, without modifying the look of the other objects sharing the material, it is recommended to simply create a new material and assign it to the object that must change. This is especially true if the object\u2019s material will be changing frequently, like a glow pulsing, light flickering etc. If an object with a frequently changing material has its own material, then sharedMaterial can be used to avoid the instantiation of a new material whenever it changes.","title":"Material Editing"},{"location":"optimization-techniques/#coroutines","text":"Coroutines are not only a way to script a series of events over a period of time, but can also be a powerful alternative to methods that execute far more frequently than is needed, and with far more overhead, such as Update() .","title":"Coroutines"},{"location":"optimization-techniques/#continuous-updates","text":"When a function needs to update on a frame-by-frame basis, but only for a set period of time (as opposed to constantly), one can use WaitForEndOfFrame within a coroutine, and only start the coroutine when needed. private IEnumerator WaitForSomething() { while(enabled) { yield return new WaitForEndOfFrame(); //better to cache this object in Start() //do something } } IMPORTANT : WaitForEndOfFrame should only be used for graphical specific functions that require operations to be performed at the very end of a frame. If your function does not require this (most don't), yield return null is the appropriate alternative.","title":"Continuous Updates"},{"location":"optimization-techniques/#delayed-updates","text":"When a function needs to update frequently, but not necessarily exactly every frame, waiting for a short time period within a loop inside a coroutine is a more efficient alternative to the Update() method. private IEnumerator WaitForSomethingElse() { while(enabled) { //0.05 equates to 20 times a second, a fairly efficient alternative to most things that // need to be constantly updated yield return new WaitForSeconds(0.05f); //do something } } WaitForFixedUpdate can also be used for physics based operations, an efficient alternative to FixedUpdate() . Please note that each of the above coroutine examples incorporate the use of a loop instead of recursion. This is because C# does not support proper tail culling in recursive statements. This means that a long running recursive function will continue to allocate stack frames, which could have the potential for issues if it runs long enough. Using a loop that is based on if the object is enabled or not is a good fix that achieves effectively the same thing as the infinitely recursive approach.","title":"Delayed Updates"},{"location":"optimization-techniques/#when-to-use-coroutines-over-update-or-fixedupdate","text":"If deciding between using a coroutine that waits for the end of the frame (or waits null ) and the standard Update() method, the best option depends on the amount of control you desire over your updating. For example, if you require the ability to stop one part of a script from updating, but not other parts, then coroutines are your best bet, as there can be multiple coroutines associated with a single MonoBehavior that can be started and stopped independently from one another. However, if your script simply requires a single constant update loop, then Update() is preferred due to less overhead per method call. In fact, Update() should always be preferred over an infinite, slightly delayed coroutine due to the overhead associated with coroutine execution. Waiting about 20 times a second using a coroutine as opposed to 60 times a second using Update() may not increase performance if the overhead of the coroutine calls exceed whatever performance is gained by running the code in the update fewer times. In summary, only use coroutines for performance purposes if the code being executed each time is very expensive.","title":"When to Use Coroutines over Update() or FixedUpdate()"},{"location":"optimization-techniques/#layer-masking","text":"When making use of trigger-related methods such as OnTriggerEnter() or OnTriggerStay() etc., consider if an opportunity to utilize layer masking becomes available. Layer masking allows for physics-based operations to ignore certain predefined layers, which can help to speed up any mechanic that is reliant on these physics-based operations, especially if they are utilized frequently or in great quantities. By only including some layers into physics calculations (such as triggers or raycasts), tag checks (or checking if needed components are on the colliding object) are avoided, speeding things up considerably. Let\u2019s say we have 2 layers: Player and PlayerOnly . PlayerOnly , as the name suggests, only collides with objects on the Player layer. When the script below is attached to an object with a trigger and the layer of PlayerOnly , no tag check is needed, because we know with certainty that it will only ever collide with the Player . private void OnTriggerEnter(Collider other) { //because this script was placed on an object with layer PlayerOnly, //no tag check is needed, and we don't need to worry about PlayerHealth not existing //on the colliding object other.GetComponent<PlayerHealth>().DoSomething(); } The downside to using layer masking instead of tag/component checking is that it is typically harder to debug, especially when many different interacting layers are involved. It is essential to carefully track each layer and plan how it may/may not interact with another to maximize the usefulness of this technique.","title":"Layer Masking"},{"location":"other/","text":"Other No magic numbers. All values other than obvious 0s, 1s, and 2s must be placed in a variable or const . Input should always be gathered in the form of virtual buttons/axes, never raw key values (except when debugging). Unused Unity methods should be removed. Even empty Start() and Updates() methods cause unnecessary overhead. Familiarize yourself with the Utilities.cs and Extensions.cs files. They contain many useful utilities for common situations, such as clamping, randomness, shuffling, and more.","title":"Other"},{"location":"other/#other","text":"No magic numbers. All values other than obvious 0s, 1s, and 2s must be placed in a variable or const . Input should always be gathered in the form of virtual buttons/axes, never raw key values (except when debugging). Unused Unity methods should be removed. Even empty Start() and Updates() methods cause unnecessary overhead. Familiarize yourself with the Utilities.cs and Extensions.cs files. They contain many useful utilities for common situations, such as clamping, randomness, shuffling, and more.","title":"Other"},{"location":"properties/","text":"Properties Accessor Types All properties should remain as private as possible. However, there are a few different common scenarios where properties might need to be public . Please follow the standards listed below according to each specific situation. Note that not all possible situations are shown below, however one should be able to extrapolate how they should handle a unique scenario based on the examples given below. Property that is public to read and public to write. This should be used instead of a public variable marked with the [HideInInspector] attribute. public int myProperty { get; set; } = 10; Property that is public to read, but private to write. public int myProperty { get; private set; } Property that is public to read, but private to write with the exception of the Inspector. Note the use of an underscore in the variable. The property name should also match the name of the variable, excluding the underscore. Lambda expressions should be used for properties only one line of code long. [SerializeField] private int _myNum = 10; public int myNum { get => _myNum; private set => _myNum = value; } Property that is inherited from a base class, public to read and write. protected int myProperty { get; set; } get / set The get and set of properties should be used when appropriate in order to check specific information, such as range limits for numbers, or other restraining conditions for a specific variable. They can also be used to trigger specific events when a property is accessed or changed. [SerializeField] private int _myNum = 10; public int myNum { get { if(someCondition) { Debug.LogError(\"Cannot get this variable for some reason!\"); return -1; } return _myNum; } set { if(value < 0) { Debug.LogError(\"myNum cannot be set to a negative number!\"); } else if(value > 10) { Debug.Log(\"myNum is greater than 10, which sets off some event of some sort!\"); EventIfMyNumOverTen(); _myNum = value; } else { _myNum = value; } } } Naming Properties should be named in either camelCase or PascalCase, depending on their purpose. camelCase If a property is a basic getter or setter with minimal logic, it should be camelCase. This is to signify that the property is nothing more than a getter/setter for a field, with no significant logic. camelCase Example 1 Basic getter property, no advanced logic. [SerializeField] private int _num; public int num => _num; camelCase Example 2 Basic getter/setter property, no advanced logic. [SerializeField] private int _num; public int num { get => _num; private set => _num = value; } camelCase Example 3 Basic getter/setter property, only simple checks. [SerializeField] private int _num; public int num { get => _num; private set { if(value != 0) { _num = value; } } } PascalCase If a property performs some sort of meaningful calculation beyond the scope of the average getter or setter, it should be PascalCase. This is to signify that the property does meaningful work when used. PascalCase Example 1 Getter property does meaningful work and creates a new string. [SerializeField] private string firstName; [SerializeField] private string lastName; public string FullName => $\"{firstName} {lastName}\"; PascalCase Example 2 Getter property does meaningful work and can create a different result each time depending on the current .position of Transform t . [SerializeField] private Transform t; [SerializeField] private Vector3 offset; public Vector3 TargetPos { get { if(t) { return t.position + offset; } return Vector3.zero; } }; PascalCase Example 3 Property with simple getter, but with a setter doing meaningful work that may involve a method call and object state change. private int _num; public int Num { get => _num; set { if(value % 3 == 0) { SomeMethod(); } _num = Mathf.Clamp(value, -100, 100); } };","title":"Properties"},{"location":"properties/#properties","text":"","title":"Properties"},{"location":"properties/#accessor-types","text":"All properties should remain as private as possible. However, there are a few different common scenarios where properties might need to be public . Please follow the standards listed below according to each specific situation. Note that not all possible situations are shown below, however one should be able to extrapolate how they should handle a unique scenario based on the examples given below. Property that is public to read and public to write. This should be used instead of a public variable marked with the [HideInInspector] attribute. public int myProperty { get; set; } = 10; Property that is public to read, but private to write. public int myProperty { get; private set; } Property that is public to read, but private to write with the exception of the Inspector. Note the use of an underscore in the variable. The property name should also match the name of the variable, excluding the underscore. Lambda expressions should be used for properties only one line of code long. [SerializeField] private int _myNum = 10; public int myNum { get => _myNum; private set => _myNum = value; } Property that is inherited from a base class, public to read and write. protected int myProperty { get; set; }","title":"Accessor Types"},{"location":"properties/#getset","text":"The get and set of properties should be used when appropriate in order to check specific information, such as range limits for numbers, or other restraining conditions for a specific variable. They can also be used to trigger specific events when a property is accessed or changed. [SerializeField] private int _myNum = 10; public int myNum { get { if(someCondition) { Debug.LogError(\"Cannot get this variable for some reason!\"); return -1; } return _myNum; } set { if(value < 0) { Debug.LogError(\"myNum cannot be set to a negative number!\"); } else if(value > 10) { Debug.Log(\"myNum is greater than 10, which sets off some event of some sort!\"); EventIfMyNumOverTen(); _myNum = value; } else { _myNum = value; } } }","title":"get/set"},{"location":"properties/#naming","text":"Properties should be named in either camelCase or PascalCase, depending on their purpose.","title":"Naming"},{"location":"properties/#camelcase","text":"If a property is a basic getter or setter with minimal logic, it should be camelCase. This is to signify that the property is nothing more than a getter/setter for a field, with no significant logic.","title":"camelCase"},{"location":"properties/#camelcase-example-1","text":"Basic getter property, no advanced logic. [SerializeField] private int _num; public int num => _num;","title":"camelCase Example 1"},{"location":"properties/#camelcase-example-2","text":"Basic getter/setter property, no advanced logic. [SerializeField] private int _num; public int num { get => _num; private set => _num = value; }","title":"camelCase Example 2"},{"location":"properties/#camelcase-example-3","text":"Basic getter/setter property, only simple checks. [SerializeField] private int _num; public int num { get => _num; private set { if(value != 0) { _num = value; } } }","title":"camelCase Example 3"},{"location":"properties/#pascalcase","text":"If a property performs some sort of meaningful calculation beyond the scope of the average getter or setter, it should be PascalCase. This is to signify that the property does meaningful work when used.","title":"PascalCase"},{"location":"properties/#pascalcase-example-1","text":"Getter property does meaningful work and creates a new string. [SerializeField] private string firstName; [SerializeField] private string lastName; public string FullName => $\"{firstName} {lastName}\";","title":"PascalCase Example 1"},{"location":"properties/#pascalcase-example-2","text":"Getter property does meaningful work and can create a different result each time depending on the current .position of Transform t . [SerializeField] private Transform t; [SerializeField] private Vector3 offset; public Vector3 TargetPos { get { if(t) { return t.position + offset; } return Vector3.zero; } };","title":"PascalCase Example 2"},{"location":"properties/#pascalcase-example-3","text":"Property with simple getter, but with a setter doing meaningful work that may involve a method call and object state change. private int _num; public int Num { get => _num; set { if(value % 3 == 0) { SomeMethod(); } _num = Mathf.Clamp(value, -100, 100); } };","title":"PascalCase Example 3"}]}